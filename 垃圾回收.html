<html><head><meta charSet="utf-8"/><title data-react-helmet="true">垃圾回收 · PHP面试常考易错问题  · 看云</title><meta data-react-helmet="true" name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"/><link rel="stylesheet" href="asset/website.css"/></head><body><div id="main"><div class="root"><div class="window-container"><div class="window-head"><div class="toolbar"><a class="title" href=".">PHP面试常考易错问题</a><div class="extra"></div></div></div><div class="progress"><div style="width:57.89473684210527%" class="progress-bar"></div></div><div class="window-body"><div class="sidebar"><div class="sidebar-selector"><div class="item active"><i class="icon content"></i>目录</div><div class="item"><i class="icon search"></i>搜索</div></div><div class="sidebar-body"><div class="catalog-body active"><ul><li class=""><div class="wholerow"></div><i class="icon"></i><a href="本文概况介绍.html" class="text">本文概况介绍</a></li><li class=""><div class="wholerow"></div><i class="icon"></i><a href="变量作用域问题.html" class="text">变量作用域问题</a></li><li class=""><div class="wholerow"></div><i class="icon"></i><a href="关于弱类型.html" class="text">关于弱类型</a></li><li class=""><div class="wholerow"></div><i class="icon"></i><a href="运算符优先级.html" class="text">运算符优先级</a></li><li class=""><div class="wholerow"></div><i class="icon"></i><a href="变量引用.html" class="text">变量引用</a></li><li class=""><div class="wholerow"></div><i class="icon"></i><a href="流程控制.html" class="text">流程控制</a></li><li class=""><div class="wholerow"></div><i class="icon"></i><a href="字符串处理.html" class="text">字符串处理</a></li><li class=""><div class="wholerow"></div><i class="icon"></i><a href="数组处理.html" class="text">数组处理</a></li><li class=""><div class="wholerow"></div><i class="icon"></i><a href="文件处理.html" class="text">文件处理</a></li><li class=""><div class="wholerow"></div><i class="icon"></i><a href="面向对象.html" class="text">面向对象</a></li><li class="active"><div class="wholerow"></div><i class="icon"></i><a href="垃圾回收.html" class="text">垃圾回收</a></li><li class=""><div class="wholerow"></div><i class="icon"></i><a href="性能优化.html" class="text">性能优化</a></li><li class=""><div class="wholerow"></div><i class="icon"></i><a href="学会避坑.html" class="text">学会避坑</a></li><li class=""><div class="wholerow"></div><i class="icon"></i><a href="内置缓存.html" class="text">内置缓存</a></li><li class=""><div class="wholerow"></div><i class="icon"></i><a href="可变变量.html" class="text">可变变量</a></li><li class=""><div class="wholerow"></div><i class="icon"></i><a href="内置常量.html" class="text">预定义常量</a></li><li class=""><div class="wholerow"></div><i class="icon"></i><a href="php.ini常考.html" class="text">php.ini常考</a></li><li class=""><div class="wholerow"></div><i class="icon"></i><a href="常考题.html" class="text">常考题</a></li><li class=""><div class="wholerow"></div><i class="icon"></i><a href="PHP知识体系.html" class="text">PHP知识体系</a></li></ul></div><div class="search-body"><div class="search-form"><form class="ui form"><div class="ui small fluid icon input"><input type="text" placeholder="请输入搜索关键词..."/><i class="search icon"></i></div></form></div><div class="search-result"><div class="blankslate"><i class="icon search"></i><p>暂无相关搜索结果！</p></div></div></div></div><div class="sidebar-copyright">本文档使用 <a href="http://www.kancloud.cn" target="_blank">看云</a> 构建</div></div><div class="workspace"><div class="article-wrap"><div class="article"><div class="article-head"><div class="left floated tools"><a class="item icon"><i class="icon align justify"></i></a></div><div class="right floated tools"></div><h1>垃圾回收</h1></div><div class="article-body"><p>垃圾回收是大多数语言的标配，设想一下假如没用垃圾回收机制，我们的程序会是一个什么样子，我们的程序还能否像我们目前这样简单的编写！</p>
<p class="align-center"><img alt="" src="images/KHO6ARRGWVUNV20ECUQP9.jpg"/></p>
<p>PHP的垃圾回收机制是一个引用计数，简单来说就是用到几次就加几，当然要遵循cow原则（引用之后并且修改将分配内存空间），销毁一次就减少一次的这样一种形式，下面就详细讲解一下：</p>
<p class="align-center"><img alt="" src="images/AHQQ6Q1BRSR%60V%60~TW9.gif"/></p>
<p>1、每一个变量定义时都保存在一个叫zval的容器里面，这里面包含了数量的类型和和值，还包含了一个refcount（理解为存在几个变量个数）和is_ref（理解为是否为引用变量）两个额外信息，当变量被引用一次refcount就会+1，当你unset一下之后这个值就会减1直到为0就会从内存中删除</p>
<p>2、定义一个变量的时候并不是每次都会扩大预定于值，因为PHP会在内存中先预占用一个空间，等你声明变量的时候就会分配给你，但是当你超出这个预占用空间之后，那么它就会增加空间，但是等你删除变量时候这个空间容量不会立即消失</p>
<p>3、变量的引用不会单独的多增加内存占用，它会指向zval结构体，只是refcount+1</p>
<p>4、简单说说，PHP的变量依赖于一个内部实现</p>
<p>symbol_table 符号表，而符号表的基础实现是 HashTable</p>
<p>，也就是和PHP数组的基础实现是一致的。真是因为符号表的存在，让我们可以使用global标记全局变量，用如compact等函数直接从当前符号表中拉出变量出来。</p>
<p>那在谈谈题主说的unset($a)会不会马上释放空间，答案是否定的，unset支持从符号表中把名字为a的这个元素删掉了（只是标记这块空间又可用了，而不是释放空间）。</p>
<p>再说循环中重复更新$key这种情况，因为更新的是相同名字的变量，所以在符号表中他们是同一个元素，更新时就会更新相同的位置，之前元素的值就马上被覆盖了。</p>
<p>再说说申明了新的变量内存就会增加这个问题，答案是不确定。这是符号表基于</p>
<p>HashTable 实现的特性所致， HashTable</p>
<p>并不是增加一个元素就申请一个元素的内存，而是一次申请多个元素的内存（只是这些位置标记是未使用），而当 HashTable</p>
<p>被塞满时，再去申请新的多个元素的内存。也就是说，当我们申明或者赋值一个变量时，如果它不在符号表中，PHP会将它加入到符号表里，而如果这时候符号表没满，那会采用符号表中已申请而未使用的内存，如果符号表刚好的满的，则会申请新的内存出来存放，而新的内存不仅仅只有这个变量需要的内存这么小</p>
<p class="align-center"><img alt="" src="images/2986969-a4376488f15c035c.jpg"/></p>
<p class="align-center"><img alt="" src="images/2986969-f0077777b32498f5.jpg"/></p>
 </div><div class="article-navigation"><span class="prev">上一篇：<a href="面向对象.html">面向对象</a></span><span class="next">下一篇：<a href="性能优化.html">性能优化</a></span></div></div></div></div></div></div></div></div><script src="asset/website.js"></script><script src="asset/plugins/highlight/index.js"></script><script type="application/payload+json">{"config":{"plugins":["highlight"],"price":100,"name":"simengphp/phpinterview","sha":"f45c62a42f098cefec2df07337a5e959238277db","title":"PHP面试常考易错问题","id":64010},"catalog":[{"id":"本文概况介绍.html","name":"本文概况介绍.md","title":"本文概况介绍","depth":1},{"id":"变量作用域问题.html","name":"变量作用域问题.md","title":"变量作用域问题","depth":1},{"id":"关于弱类型.html","name":"关于弱类型.md","title":"关于弱类型","depth":1},{"id":"运算符优先级.html","name":"运算符优先级.md","title":"运算符优先级","depth":1},{"id":"变量引用.html","name":"变量引用.md","title":"变量引用","depth":1},{"id":"流程控制.html","name":"流程控制.md","title":"流程控制","depth":1},{"id":"字符串处理.html","name":"字符串处理.md","title":"字符串处理","depth":1},{"id":"数组处理.html","name":"数组处理.md","title":"数组处理","depth":1},{"id":"文件处理.html","name":"文件处理.md","title":"文件处理","depth":1},{"id":"面向对象.html","name":"面向对象.md","title":"面向对象","depth":1},{"id":"垃圾回收.html","name":"垃圾回收.md","title":"垃圾回收","depth":1},{"id":"性能优化.html","name":"性能优化.md","title":"性能优化","depth":1},{"id":"学会避坑.html","name":"学会避坑.md","title":"学会避坑","depth":1},{"id":"内置缓存.html","name":"内置缓存.md","title":"内置缓存","depth":1},{"id":"可变变量.html","name":"可变变量.md","title":"可变变量","depth":1},{"id":"内置常量.html","name":"内置常量.md","title":"预定义常量","depth":1},{"id":"php.ini常考.html","name":"php.ini常考.md","title":"php.ini常考","depth":1},{"id":"常考题.html","name":"常考题.md","title":"常考题","depth":1},{"id":"PHP知识体系.html","name":"PHP知识体系.md","title":"PHP知识体系","depth":1}],"article":{"id":"垃圾回收.html","name":"垃圾回收.md","title":"垃圾回收","content":"垃圾回收是大多数语言的标配，设想一下假如没用垃圾回收机制，我们的程序会是一个什么样子，我们的程序还能否像我们目前这样简单的编写！\n:-: ![](images/KHO6ARRGWVUNV20ECUQP9.jpg)\n\nPHP的垃圾回收机制是一个引用计数，简单来说就是用到几次就加几，当然要遵循cow原则（引用之后并且修改将分配内存空间），销毁一次就减少一次的这样一种形式，下面就详细讲解一下：\n\n:-: ![](images/AHQQ6Q1BRSR`V`~TW9.gif)\n\n1、每一个变量定义时都保存在一个叫zval的容器里面，这里面包含了数量的类型和和值，还包含了一个refcount（理解为存在几个变量个数）和is_ref（理解为是否为引用变量）两个额外信息，当变量被引用一次refcount就会+1，当你unset一下之后这个值就会减1直到为0就会从内存中删除\n\n2、定义一个变量的时候并不是每次都会扩大预定于值，因为PHP会在内存中先预占用一个空间，等你声明变量的时候就会分配给你，但是当你超出这个预占用空间之后，那么它就会增加空间，但是等你删除变量时候这个空间容量不会立即消失\n\n3、变量的引用不会单独的多增加内存占用，它会指向zval结构体，只是refcount+1\n\n4、简单说说，PHP的变量依赖于一个内部实现\n\nsymbol_table 符号表，而符号表的基础实现是 HashTable\n\n，也就是和PHP数组的基础实现是一致的。真是因为符号表的存在，让我们可以使用global标记全局变量，用如compact等函数直接从当前符号表中拉出变量出来。\n\n那在谈谈题主说的unset($a)会不会马上释放空间，答案是否定的，unset支持从符号表中把名字为a的这个元素删掉了（只是标记这块空间又可用了，而不是释放空间）。\n\n再说循环中重复更新$key这种情况，因为更新的是相同名字的变量，所以在符号表中他们是同一个元素，更新时就会更新相同的位置，之前元素的值就马上被覆盖了。\n\n再说说申明了新的变量内存就会增加这个问题，答案是不确定。这是符号表基于\n\nHashTable 实现的特性所致， HashTable\n\n并不是增加一个元素就申请一个元素的内存，而是一次申请多个元素的内存（只是这些位置标记是未使用），而当 HashTable\n\n被塞满时，再去申请新的多个元素的内存。也就是说，当我们申明或者赋值一个变量时，如果它不在符号表中，PHP会将它加入到符号表里，而如果这时候符号表没满，那会采用符号表中已申请而未使用的内存，如果符号表刚好的满的，则会申请新的内存出来存放，而新的内存不仅仅只有这个变量需要的内存这么小\n\n\n\n:-: ![](images/2986969-a4376488f15c035c.jpg)\n:-: ![](images/2986969-f0077777b32498f5.jpg)"},"options":{"plugins_host":null,"context":"website","base":"./","features":["search","internal_link"]},"style":""}</script><script type="text/javascript">kancloud.bootstrap();</script></body></html>